using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class S_CultivableCube : MonoBehaviour
{
    public string growthTag = "Player";  // Tag qui déclenche la croissance
    public string growingStateTag = "Growing";  // Tag assigné lors de la croissance
    public GameObject growthPrefab;  // Préfabriqué à générer pendant la croissance
    public Vector3 growthRange = new Vector3(2f, 1f, 2f);  // Plage de croissance autour et au-dessus
    public bool isGrowing = false;  // Indique si le cube est en mode croissance
    public bool visualizeRange = true;  // Option de visualisation dans la scène

    private Vector3 currentGrowthCenter; // La position actuelle du dernier point de croissance
    private Rigidbody rb;  // Référence au composant Rigidbody pour gérer la physique

    private float collisionCooldown = 1.0f; // Délai de refroidissement (en secondes)
    private bool isCooldown = false;  // Indique si le refroidissement est actif

    // S'abonner à l'événement de réinitialisation lors de l'activation
    void OnEnable()
    {
        S_ZoneResetSysteme.OnZoneReset += Grow;
    }

    // Se désabonner de l'événement de réinitialisation lors de la désactivation
    void OnDisable()
    {
        S_ZoneResetSysteme.OnZoneReset -= Grow;
    }

    void Start()
    {
        isGrowing = false;
        // Obtenir le Rigidbody pour gérer le déplacement physique
        rb = GetComponent<Rigidbody>();
        if (rb == null)
        {
            rb = gameObject.AddComponent<Rigidbody>();  // Si le Rigidbody n'existe pas, en ajouter un
        }
    }

    // Détecter la collision avec un objet ayant le bon tag pour démarrer la croissance ou réinitialiser
    void OnCollisionEnter(Collision collision)
    {
        if (!isCooldown && collision.gameObject.CompareTag(growthTag))
        {
            if (isGrowing)
            {
                // Si en mode croissance, réinitialiser l'état
                ResetGrowth();
            }
            else
            {
                // Démarrer la croissance si elle n'est pas active
                isGrowing = true;
                rb.isKinematic = true;  // Désactiver le mouvement physique lors de la croissance
                currentGrowthCenter = transform.position;
                SetTags(growingStateTag); // Ajouter le tag "Growing" à l'objet et ses enfants
                Debug.Log("Cube en mode croissance.");
            }

            // Activer le refroidissement pour empêcher les collisions rapides
            StartCoroutine(CollisionCooldownCoroutine());
        }
    }

    // Coroutine pour gérer le délai de refroidissement des collisions
    private IEnumerator CollisionCooldownCoroutine()
    {
        isCooldown = true;
        yield return new WaitForSeconds(collisionCooldown);
        isCooldown = false;
    }

    // Croissance du cube à chaque reset
    public void Grow()
    {
        if (!isGrowing) return;

        // Utiliser le dernier enfant comme centre de croissance
        if (transform.childCount > 0)
        {
            currentGrowthCenter = transform.GetChild(transform.childCount - 1).position;
        }

        // Définir un point de croissance aléatoire dans la plage définie
        Vector3 randomPosition = currentGrowthCenter + new Vector3(
            Random.Range(-growthRange.x, growthRange.x),
            Random.Range(0, growthRange.y),  // Seulement vers le haut
            Random.Range(-growthRange.z, growthRange.z)
        );

        // Générer le préfabriqué à la nouvelle position
        GameObject newGrowth = Instantiate(growthPrefab, randomPosition, Quaternion.identity, this.transform);

        // Mettre à jour le centre de croissance à la nouvelle position
        currentGrowthCenter = newGrowth.transform.position;

        Debug.Log("Nouveau préfabriqué généré à : " + randomPosition);
    }

    // Réinitialiser la croissance en détruisant tous les enfants sauf le centre
    private void ResetGrowth()
    {
        Debug.Log("Réinitialisation du cube et suppression des branches.");

        // Parcourir les enfants et détruire tous sauf le premier enfant
        for (int i = transform.childCount - 1; i > 0; i--)
        {
            Destroy(transform.GetChild(i).gameObject);
        }

        // Remettre le cube à l'état de départ
        isGrowing = false;
        rb.isKinematic = false;  // Autoriser de nouveau le mouvement physique
        RemoveTags(); // Retirer le tag "Growing" de l'objet et de ses enfants
    }

    // Ajouter un tag à l'objet et à tous ses enfants
    private void SetTags(string tag)
    {
        gameObject.tag = tag;
        foreach (Transform child in transform)
        {
            child.gameObject.tag = tag;
        }
    }

    // Retirer un tag en réinitialisant à "Untagged"
    private void RemoveTags()
    {
        gameObject.tag = "Untagged";
        foreach (Transform child in transform)
        {
            child.gameObject.tag = "Untagged";
        }
    }

    // Visualiser la plage de croissance dans la scène avec des Gizmos
    private void OnDrawGizmos()
    {
        if (visualizeRange)
        {
            Vector3 gizmoCenter = currentGrowthCenter == Vector3.zero ? transform.position : currentGrowthCenter;
            gizmoCenter += new Vector3(0, growthRange.y / 2, 0);
            Gizmos.color = Color.green;
            Gizmos.DrawWireCube(gizmoCenter, growthRange);
        }
    }
}
